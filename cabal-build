#!/bin/sh

# A cabal-build wrapper for use by 0compile. The setup is:
# $SRCDIR:   A read-only unpacked directory containing the source code
# $BUILDDIR: A writeable temp dir
# $DESTDIR:  A writeable destination dir which will become the published artifact.
#            It is CRITICAL that no files in here reference $DESTDIR, as it must
#            be relocatable.
#
# The process should *not* touch (or even read) ~/.cabal/*

set -eux
cd "$SRCDIR"

# use a throwaway cabal config to isolate us from global config
# TODO: do we need to allow user config to be used for e.g proxy setup?
export CABAL_CONFIG="$BUILDDIR/cabal.conf"

# cabal (or ghc?) really wants a package db
# but doesn't do anything with it (and we do NOT want to include it in $DISTDIR)
pkgdb="$BUILDDIR/package.d.UNUSED"
ghc-pkg init "$pkgdb"

cabal configure -v --builddir="$BUILDDIR" --prefix="$DISTDIR" --package-db="$pkgdb"
cabal build -v --builddir="$BUILDDIR"

# copy takes its dest from the configured --prefix. If you specify --destdir here,
# you end up with double-paths (i.e $PREFIX/$PREFIX/...)"
cabal copy --builddir="$BUILDDIR"

# generate a pkg file in the $BUILDDIR, which we transform later to be relocatable
# note the --inplace - without this cabal will generate a package.conf
# that can't actually be used for anything except registering it later
# (which doesn't even seem to work for relocatable packages).
cabal register -v --gen-pkg-config="$BUILDDIR/package.conf" --builddir="$BUILDDIR"

set +x # You don't want to see this ;)
echo "making package description prefix-independant.."

# Totally hacky. I'd use sed, but then I have to worry about metachars.
# And python is probably installed if you're using 0compile.
python -c 'from __future__ import print_function;
import os, sys;
prefixes=(os.environ["DISTDIR"], os.environ["BUILDDIR"]);
replacement="${pkgroot}"
for line in sys.stdin:
	for prefix in prefixes:
		print("replacing %s with %s" % (prefix, replacement), file=sys.stderr)
		line = line.replace(prefix, replacement)
	line = line.replace(replacement + "/build", replacement + "/lib") # TODO: how does this happen?
	print(line, end="")' < "$BUILDDIR/package.conf.inplace" > "$DISTDIR/package.conf"

# preemptively check for hard coded paths.
hard_coded_files=`fgrep -R "$DISTDIR" "$DISTDIR" || fgrep -R "$BUILDDIR" "$DISTDIR" || true`
if [ -n "$hard_coded_files" ]; then
	# TODO: this might be too strict when such paths are used only as
	# defaults, but that's less likely than having missed something at this point
	echo ''
	echo 'ERROR: found hard-coded in the following files:'
	echo "$hard_coded_files"
	echo ''
	echo 'The resulting archive will NOT be relocatable.'
	exit 1
fi
