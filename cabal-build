#!/bin/sh

# A cabal-build wrapper for use by 0compile. The setup is:
# $SRCDIR:   A read-only unpacked directory containing the source code
# $BUILDDIR: A writeable temp dir
# $DESTDIR:  A writeable destination dir which will become the published artifact.
#            It is CRITICAL that no files in here reference $DESTDIR, as it must
#            be relocatable.
#
# The process should *not* touch (or even read) ~/.cabal/*

set -eux
cd "$SRCDIR"

# use a throwaway cabal config to isolate us from global config
# TODO: do we need to allow user config to be used for e.g proxy setup?
export CABAL_CONFIG="$BUILDDIR/cabal.conf"

# cabal (or ghc?) really wants a package db
# but doesn't do anything with it (and we do NOT want to include it in $DISTDIR)
pkgdb="$BUILDDIR/package.d.UNUSED"
ghc-pkg init "$pkgdb"

cabal configure -v --builddir="$BUILDDIR" --prefix="$DISTDIR" --package-db="$pkgdb"
cabal build -v --builddir="$BUILDDIR"

# copy takes its dest from the configured --prefix. If you specify --destdir here,
# you end up with double-paths (i.e $PREFIX/$PREFIX/...)"
cabal copy --builddir="$BUILDDIR"

# generate a pkg file in the $BUILDDIR, which we transform later to be relocatable
# note the --inplace - without this cabal will generate a package.conf
# that can't actually be used for anything except registering it later
# (which doesn't even seem to work for relocatable packages).
cabal register -v --inplace --gen-pkg-config="$BUILDDIR/package.conf" --builddir="$BUILDDIR"

set +x # You don't want to see this ;)
echo "making package description prefix-independant.."

# Totally hacky. I'd use sed, but then I have to worry about metachars.
# And python is probably installed if you're using 0compile.
python -c 'from __future__ import print_function;
import os, sys;
prefix=os.environ["DISTDIR"];
for line in sys.stdin:
	print(line.replace(prefix, "${pkgroot}"), end="")' < "$BUILDDIR/package.conf.inplace" > "$DISTDIR/package.conf"

# preemptively check for hard coded paths.
hard_coded_files=`fgrep -R -l "$DISTDIR" "$DISTDIR" || true`
if [ -n "$hard_coded_files" ]; then
	# TODO: this might be too strict when such paths are used only as
	# defaults, but that's less likely than having missed something at this point
	echo ''
	echo 'ERROR: found $DISTDIR hard-coded in the following files:'
	echo "$hard_coded_files"
	echo ''
	echo 'The resulting binary will NOT be relocatable.'
	exit 1
fi
